/**
 * @fileoverview Shared constants and helpers for ESLint configuration.
 */

import fs from "fs";
import path from "path";

/** Project root directory (resolved from the consuming project's CWD) */
const PROJECT_ROOT = process.cwd();

/**
 * Root directories containing feature modules.
 * @type {string[]}
 */
export const FEATURE_ROOTS = [
  "src/features",
  "scripts/features",
  "supabase/functions/features",
];

/**
 * Files and directories to exclude from prefix mapping.
 * @type {string[]}
 */
const EXCLUDE_LIST = ["proxy.ts", "types"];

/**
 * Generate PREFIX_LIB_MAPPING by scanning src/lib/ directory.
 *
 * @returns {Record<string, string>} Mapping of prefix to lib import path.
 * @example
 * - src/lib/supabase/server.ts → { server: "@/lib/supabase/server" }
 * - src/lib/supabase/client.ts → { server: "@/lib/supabase/client" }
 */
function generatePrefixLibMapping() {
  const libDir = path.join(PROJECT_ROOT, "src/lib");
  const mapping = {};

  if (!fs.existsSync(libDir)) {
    return mapping;
  }

  const entries = fs.readdirSync(libDir, { withFileTypes: true });

  for (const entry of entries) {
    if (EXCLUDE_LIST.includes(entry.name)) {
      continue;
    }

    if (entry.isDirectory()) {
      // Scan subdirectory (e.g., src/lib/supabase/)
      const subDir = path.join(libDir, entry.name);
      const subEntries = fs.readdirSync(subDir, { withFileTypes: true });

      for (const subEntry of subEntries) {
        if (
          subEntry.isFile() &&
          subEntry.name.endsWith(".ts") &&
          !EXCLUDE_LIST.includes(subEntry.name)
        ) {
          const prefix = subEntry.name.replace(".ts", "");
          mapping[prefix] = `@/lib/${entry.name}/${prefix}`;
        }
      }
    } else if (entry.isFile() && entry.name.endsWith(".ts")) {
      const prefix = entry.name.replace(".ts", "");
      mapping[prefix] = `@/lib/${prefix}`;
    }
  }

  return mapping;
}

/**
 * Mapping of file prefixes to their corresponding lib imports.
 *
 * Dynamically generated by scanning src/lib/ directory.
 * Used by:
 * - naming.mjs: Validates file naming (e.g., server.repo.ts, client.repo.ts)
 * - imports.mjs: Enforces import restrictions
 *
 * @example
 * server.repo.ts → can only import @/lib/supabase/server
 * client.repo.ts → can only import @/lib/supabase/client
 *
 * @type {Record<string, string>}
 */
export const PREFIX_LIB_MAPPING = generatePrefixLibMapping();

/**
 * Creates glob patterns for all feature roots.
 * @param {string} subpath - The subpath to append to each feature root.
 * @returns {string[]} Array of glob patterns.
 * @example
 * featuresGlob("**\/actions/*.ts")
 * // => ["src/features/**\/actions/*.ts", "scripts/features/**\/actions/*.ts", ...]
 */
export const featuresGlob = (subpath) =>
  FEATURE_ROOTS.map((root) => `${root}/${subpath}`);
